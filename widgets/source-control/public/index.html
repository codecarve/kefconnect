<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>KEF Source Control</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="widget-container">
    <!-- Source Grid -->
    <div class="source-grid" id="sourceGrid" role="radiogroup" aria-label="Audio source selection">
      <button class="source-btn" data-source="wifi" role="radio" aria-checked="false" aria-label="WiFi">
        <svg viewBox="0 0 24 24">
          <path d="M1 9l2 2c4.97-4.97 13.03-4.97 18 0l2-2C16.93 2.93 7.08 2.93 1 9zm8 8l3 3 3-3c-1.65-1.66-4.34-1.66-6 0zm-4-4l2 2c2.76-2.76 7.24-2.76 10 0l2-2C15.14 9.14 8.87 9.14 5 13z"/>
        </svg>
        <span>Wi-Fi</span>
      </button>
      <button class="source-btn" data-source="bluetooth" role="radio" aria-checked="false" aria-label="Bluetooth">
        <svg viewBox="0 0 24 24">
          <path d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z"/>
        </svg>
        <span>Bluetooth</span>
      </button>
      <button class="source-btn" data-source="tv" role="radio" aria-checked="false" aria-label="TV">
        <svg viewBox="0 0 24 24">
          <path d="M21 3H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h5v2h8v-2h5c1.1 0 1.99-.9 1.99-2L23 5c0-1.1-.9-2-2-2zm0 14H3V5h18v12z"/>
        </svg>
        <span>TV</span>
      </button>
      <button class="source-btn" data-source="optical" role="radio" aria-checked="false" aria-label="Optical">
        <svg viewBox="0 0 24 24">
          <path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H5V10h3v10zm4 0H9V4h3v16zm4 0h-3v-6h3v6z"/>
        </svg>
        <span>Optical</span>
      </button>
      <button class="source-btn" data-source="usb" role="radio" aria-checked="false" aria-label="USB">
        <svg viewBox="0 0 24 24">
          <path d="M15 7v4h1v2h-3V5h2l-3-4-3 4h2v8H8v-2.07c.7-.37 1.2-1.08 1.2-1.93 0-1.21-.99-2.2-2.2-2.2-1.21 0-2.2.99-2.2 2.2 0 .85.5 1.56 1.2 1.93V13c0 1.11.89 2 2 2h3v3.05c-.71.37-1.2 1.1-1.2 1.95 0 1.22.99 2.2 2.2 2.2 1.21 0 2.2-.98 2.2-2.2 0-.85-.49-1.58-1.2-1.95V15h3c1.11 0 2-.89 2-2v-2h1V7h-4z"/>
        </svg>
        <span>USB</span>
      </button>
      <button class="source-btn" data-source="analog" role="radio" aria-checked="false" aria-label="AUX">
        <svg viewBox="0 0 24 24">
          <path d="M11 14V6c0-.55.45-1 1-1s1 .45 1 1v8c0 .55-.45 1-1 1s-1-.45-1-1zM9 14V6c0-1.66 1.34-3 3-3s3 1.34 3 3v8c0 1.66-1.34 3-3 3s-3-1.34-3-3zm3 7c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"/>
        </svg>
        <span>AUX</span>
      </button>
      <button class="source-btn" data-source="coaxial" role="radio" aria-checked="false" aria-label="Coaxial" style="display:none">
        <svg viewBox="0 0 24 24">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"/>
          <circle cx="12" cy="12" r="3"/>
        </svg>
        <span>Coaxial</span>
      </button>
    </div>

    <!-- Offline Overlay -->
    <div class="offline-overlay" id="offlineOverlay" style="display:none" role="alert" aria-live="assertive">
      <svg class="offline-icon" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M23.64 7c-.45-.34-4.93-4-11.64-4-1.5 0-2.89.19-4.15.48L18.18 13.8 23.64 7zm-6.6 8.22L3.27 1.44 2 2.72l2.05 2.06C1.91 5.76.59 6.82.36 7l11.63 14.49.01.01.01-.01 3.9-4.86 3.32 3.32 1.27-1.27-3.46-3.46z"/>
      </svg>
      <div class="offline-text">Device Offline</div>
    </div>
  </div>

  <script type="text/javascript">
    let widgetSettings = {};
    let currentState = null;
    let refreshInterval = null;
    let isUpdating = false;
    let pendingSource = null;
    let pendingTimestamp = null;
    let pendingTimeout = null;

    // Initialize the widget when the Homey SDK is ready
    function onHomeyReady(Homey) {
      // Signal Homey that the widget is ready with proper height
      Homey.ready({ height: 220 });

      // Initialize the widget
      initWidget();
    }

    // Initialize widget
    async function initWidget() {
      try {
        widgetSettings = await window.Homey.getSettings();

        // Get selected device ID using the new devices API
        const deviceIds = await window.Homey.getDeviceIds();

        if (!deviceIds || deviceIds.length === 0) {
          showError('Please select a device in widget settings');
          return;
        }

        // Store the first device ID (since we use singular: true)
        widgetSettings.device = deviceIds[0];

        const interval = (widgetSettings.refresh_interval || 3) * 1000;

        await updateDeviceState();

        if (refreshInterval) {
          clearInterval(refreshInterval);
        }
        refreshInterval = setInterval(updateDeviceState, interval);

        setupEventListeners();

      } catch (error) {
        showError('Failed to initialize');
      }
    }

    // Set up event listeners
    function setupEventListeners() {
      // Source buttons
      const sourceButtons = document.querySelectorAll('.source-btn');
      sourceButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          const source = btn.dataset.source;
          if (source) {
            selectSource(source);
          }
        });
      });
    }

    // Update device state
    async function updateDeviceState() {
      if (isUpdating) return;
      isUpdating = true;

      try {
        const response = await window.Homey.api('GET', `/device-state?deviceId=${widgetSettings.device}`);

        currentState = response;

        // Check if pending source has been confirmed
        if (pendingSource && response.source === pendingSource) {
          clearPendingState();
        }

        updateUI(response);

        document.getElementById('offlineOverlay').style.display = response.available ? 'none' : 'flex';

      } catch (error) {
        showOffline();
      } finally {
        isUpdating = false;
      }
    }

    // Update UI with device state
    function updateUI(state) {
      // Configure source buttons
      const hiddenSources = widgetSettings.hide_sources ?
        widgetSettings.hide_sources.split(',').map(s => s.trim().toLowerCase()) : [];

      const sourceButtons = document.querySelectorAll('.source-btn');
      sourceButtons.forEach(btn => {
        const source = btn.dataset.source;

        // Hide sources that are:
        // 1. Not supported by the device model
        // 2. Hidden by user preference
        const isSupported = state.supportedSources && state.supportedSources.includes(source);
        const isHiddenByUser = hiddenSources.includes(source);

        if (!isSupported || isHiddenByUser) {
          btn.style.display = 'none';
        } else {
          btn.style.display = '';
        }

        // Determine which source to show as active
        const displaySource = pendingSource || state.source;
        const isActive = source === displaySource;
        const isPending = source === pendingSource;

        btn.classList.toggle('active', isActive);
        btn.classList.toggle('pending', isPending);
        btn.setAttribute('aria-checked', isActive ? 'true' : 'false');

        // Disable ALL buttons when there's a pending source change (including the pending button itself)
        // This prevents rapid clicking and race conditions
        btn.disabled = !state.available || (pendingSource !== null);
      });

      // Disable controls if device is unavailable
      const container = document.querySelector('.widget-container');
      container.classList.toggle('disabled', !state.available);
    }

    // Clear pending state
    function clearPendingState() {
      pendingSource = null;
      pendingTimestamp = null;
      if (pendingTimeout) {
        clearTimeout(pendingTimeout);
        pendingTimeout = null;
      }
    }

    // Select source
    async function selectSource(source) {
      // Guard against multiple simultaneous calls
      if (!currentState || !currentState.available) return;
      if (pendingSource !== null) return; // Already processing a change

      try {
        if (window.Homey && window.Homey.hapticFeedback) {
          window.Homey.hapticFeedback();
        }

        // Set optimistic state immediately and lock UI
        pendingSource = source;
        pendingTimestamp = Date.now();
        updateUI(currentState); // Refresh UI with pending state (disables all buttons)

        // Calculate timeout: refresh_interval + 1 second
        const timeoutMs = ((widgetSettings.refresh_interval || 3) + 1) * 1000;
        pendingTimeout = setTimeout(() => {
          // Timeout reached - clear pending state and revert to actual state
          clearPendingState();
          if (currentState) {
            updateUI(currentState);
          }
        }, timeoutMs);

        // Send the command
        await window.Homey.api('POST', '/source', {
          deviceId: widgetSettings.device,
          source: source
        });

        // Trigger an immediate poll to verify
        setTimeout(() => {
          updateDeviceState();
        }, 200);

      } catch (error) {
        // On error, clear pending state and revert
        clearPendingState();
        if (currentState) {
          updateUI(currentState);
        }
      }
    }

    // Send command to device
    async function sendCommand(command, value = null) {
      try {
        if (window.Homey && window.Homey.hapticFeedback) {
          window.Homey.hapticFeedback();
        }

        await window.Homey.api('POST', '/command', {
          deviceId: widgetSettings.device,
          command: command,
          value: value
        });

        setTimeout(updateDeviceState, 500);

      } catch (error) {
        // Silently fail - the UI will update on next refresh
      }
    }

    // Show offline state
    function showOffline() {
      document.getElementById('offlineOverlay').style.display = 'flex';
    }

    // Show error message
    function showError(message) {
      // Create an error overlay since this widget doesn't have track info elements
      const offlineOverlay = document.getElementById('offlineOverlay');
      const offlineText = offlineOverlay.querySelector('.offline-text');
      if (offlineText) {
        offlineText.textContent = message;
      }
      offlineOverlay.style.display = 'flex';

      const container = document.querySelector('.widget-container');
      container.classList.add('disabled');
    }

    // Clean up
    window.addEventListener('beforeunload', () => {
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
    });
  </script>
  <!-- Homey SDK is injected automatically -->
</body>
</html>
